#!/usr/bin/env node
// src/scripts/update-metadata.ts
import fs from 'fs';
import path from 'path';
import { documentationMetadata, ToolDocumentation } from '../utils/documentation-metadata.js';

/**
 * Update the lastUpdated dates based on file system timestamps
 * @returns Updated metadata array
 */
function updateLastUpdatedDates(): ToolDocumentation[] {
  console.log('Updating lastUpdated dates based on file system...');
  
  const updatedMetadata = [...documentationMetadata];
  let updatedCount = 0;
  
  updatedMetadata.forEach(doc => {
    try {
      if (fs.existsSync(doc.path)) {
        const stats = fs.statSync(doc.path);
        const fileDate = new Date(stats.mtime);
        
        // Only update if the file is newer than our record
        if (fileDate > doc.lastUpdated) {
          doc.lastUpdated = fileDate;
          updatedCount++;
          console.log(`Updated: ${doc.name} (${doc.path}) -> ${fileDate.toISOString()}`);
        }
      } else {
        console.warn(`Warning: File not found: ${doc.path}`);
      }
    } catch (error) {
      console.error(`Error checking file ${doc.path}:`, error);
    }
  });
  
  console.log(`Updated ${updatedCount} document(s)`);
  return updatedMetadata;
}

/**
 * Write updated metadata back to the source file
 * @param updatedMetadata The updated metadata array
 */
function writeUpdatedMetadata(updatedMetadata: ToolDocumentation[]) {
  const metadataFilePath = path.join(__dirname, '../utils/documentation-metadata.ts');
  
  console.log(`Writing updated metadata to ${metadataFilePath}...`);
  
  // Create a formatted date replacement function for JSON.stringify
  const replacer = (key: string, value: any) => {
    if (key === 'lastUpdated' && value instanceof Date) {
      return `new Date("${value.toISOString()}")`;
    }
    return value;
  };
  
  // Format the metadata as TypeScript code
  // We need to handle the Date objects specially
  let metadataString = JSON.stringify(updatedMetadata, replacer, 2);
  // Replace the "new Date(...)" strings with actual new Date() expressions
  metadataString = metadataString.replace(/"new Date\(\\\"(.+?)\\\"\)"/g, 'new Date("$1")');
  
  // Build the full TypeScript file content
  const fileContent = `// src/utils/documentation-metadata.ts
// Auto-generated by update-metadata.ts on ${new Date().toISOString()}
// Do not edit this file directly

export interface ToolDocumentation {
  name: string;           // Name of the document
  path: string;           // File path relative to project root
  description: string;    // Brief description of content
  toolCoverage: string[]; // Tools documented in this file
  lastUpdated: Date;      // Last modification date
}

export const documentationMetadata: ToolDocumentation[] = ${metadataString};

// Tool-specific documentation location map
export const toolDocumentationMap: Record<string, string[]> = {
  "execute_command": ["MCP_TOOLS_INVENTORY.md", "DOCUMENTATION.md"],
  "read_output": ["MCP_TOOLS_INVENTORY.md"],
  "force_terminate": ["MCP_TOOLS_INVENTORY.md"],
  "list_sessions": ["MCP_TOOLS_INVENTORY.md"],
  "list_processes": ["MCP_TOOLS_INVENTORY.md", "DOCUMENTATION.md"],
  "kill_process": ["MCP_TOOLS_INVENTORY.md", "DOCUMENTATION.md"],
  "block_command": ["MCP_TOOLS_INVENTORY.md"],
  "unblock_command": ["MCP_TOOLS_INVENTORY.md"],
  "read_file": ["MCP_TOOLS_INVENTORY.md", "DOCUMENTATION.md"],
  "write_file": ["MCP_TOOLS_INVENTORY.md", "DOCUMENTATION.md"],
  "create_directory": ["MCP_TOOLS_INVENTORY.md"],
  "list_directory": ["MCP_TOOLS_INVENTORY.md"],
  "move_file": ["MCP_TOOLS_INVENTORY.md"],
  "search_files": ["MCP_TOOLS_INVENTORY.md"],
  "get_file_info": ["MCP_TOOLS_INVENTORY.md"],
  "edit_block": ["MCP_TOOLS_INVENTORY.md", "DOCUMENTATION.md"],
  "code_analyzer": ["MCP_TOOLS_INVENTORY.md", "CODE_ANALYZER_SETUP.md", "DOCUMENTATION.md", "CODE_ANALYZER_CHANGELOG.md"],
  "query_codebase": ["MCP_TOOLS_INVENTORY.md", "CODE_ANALYZER_SETUP.md", "CODE_ANALYZER_CHANGELOG.md"]
};`;

  // Write the file
  fs.writeFileSync(metadataFilePath, fileContent);
  console.log('Updated metadata written successfully');
}

/**
 * Generate a tool documentation map from the metadata
 * This function analyzes the toolCoverage arrays and creates a mapping from tool to documentation
 * @param metadata The documentation metadata array
 * @returns A record mapping tool names to documentation paths
 */
function generateToolDocumentationMap(metadata: ToolDocumentation[]): Record<string, string[]> {
  console.log('Generating tool documentation map...');
  
  const toolMap: Record<string, Set<string>> = {};
  
  // Build the initial map with Sets to avoid duplicates
  metadata.forEach(doc => {
    doc.toolCoverage.forEach(tool => {
      if (tool === 'All MCP tools' || tool === 'N/A') {
        return; // Skip special values
      }
      
      if (!toolMap[tool]) {
        toolMap[tool] = new Set<string>();
      }
      
      toolMap[tool].add(doc.path);
    });
  });
  
  // Convert Sets to arrays for the final output
  const result: Record<string, string[]> = {};
  Object.entries(toolMap).forEach(([tool, paths]) => {
    result[tool] = Array.from(paths);
  });
  
  console.log(`Generated map for ${Object.keys(result).length} tools`);
  return result;
}

/**
 * Main function to run the metadata update process
 */
function main() {
  console.log('Starting metadata update process...');
  
  // Update lastUpdated dates
  const updatedMetadata = updateLastUpdatedDates();
  
  // Optionally regenerate the tool documentation map
  // Uncomment this if you want to generate the map based on the metadata
  // const generatedMap = generateToolDocumentationMap(updatedMetadata);
  
  // Write the updated metadata back to the file
  writeUpdatedMetadata(updatedMetadata);
  
  console.log('Metadata update process completed');
}

// Run the update if this script is executed directly
// For ES modules, we need to use a different way to check if this is the main module
if (import.meta.url.endsWith(process.argv[1])) {
  main();
}

export { updateLastUpdatedDates, generateToolDocumentationMap };